# OWASP Vulnerability Types: Implementation Challenges

This document details the specific challenges and considerations for each of the 10 OWASP vulnerability types in SafeCode's challenge generation system.

**Last Updated:** February 5, 2026
**Status:** Week 1 - Initial implementation complete, testing in progress

---

## Overview

Each vulnerability type has different implementation characteristics that affect challenge generation success rates. This document serves as a reference for understanding what works well and what needs refinement.

---

## 1. SQL Injection (sqli)

**Status:** ✅ **Working Perfectly**

### Characteristics
- Self-contained with sqlite3
- Uses in-memory database (`:memory:`)
- No external dependencies

### Why It Works Well
- Python's sqlite3 is built-in
- In-memory databases are fast and isolated
- Clear distinction between parameterized queries (secure) and string formatting (insecure)
- Tests can set up schema and data in fixtures

### Implementation Pattern
```python
# Secure: Uses parameterized queries
cursor.execute("SELECT * FROM users WHERE id = ?", (user_id,))

# Insecure: String formatting
cursor.execute(f"SELECT * FROM users WHERE id = {user_id}")
```

### Potential Issues
- Tests must properly set up database schema and insert test data
- LLM must understand that tests need database fixtures
- Shared in-memory database state can be tricky

### Success Rate (Expected)
**95-100%** - Most reliable vulnerability type

---

## 2. Cross-Site Scripting (XSS)

**Status:** ✅ **Working Well**

### Characteristics
- HTML generation without web framework
- Uses Python's built-in `html.escape()`
- Pure string manipulation

### Why It Works Well
- No external dependencies (html module is built-in)
- Clear secure vs insecure pattern
- Easy to test with string assertions

### Implementation Pattern
```python
# Secure: Escapes HTML
safe_content = html.escape(user_input)
return f"<div>{safe_content}</div>"

# Insecure: Direct insertion
return f"<div>{user_input}</div>"
```

### Potential Issues
- Code length requirement (20-35 lines) can be challenging
- LLM might try to use Flask/Django templates (not available in container)
- Must ensure both versions define the same function name

### Success Rate (Expected)
**85-95%** - Very reliable with proper prompting

---

## 3. Path Traversal (path_traversal)

**Status:** ⚠️ **Needs Testing**

### Characteristics
- Path validation logic
- No actual file operations required
- Uses `os.path` functions

### Why It Should Work
- Built-in `os.path` module available
- Simple validation logic
- Clear secure (reject `..`) vs insecure (accept anything) pattern

### Implementation Pattern
```python
# Secure: Validates path
if '..' in filename or filename.startswith('/'):
    return None
return os.path.join(base_dir, filename)

# Insecure: No validation
return os.path.join(base_dir, filename)
```

### Potential Issues
- LLM might try to actually open files (should only validate paths)
- Tests need to verify validation logic, not file system access
- May need clearer prompting to avoid file operations

### Success Rate (Expected)
**70-85%** - Should work with refinement

---

## 4. Command Injection (cmdi)

**Status:** ⚠️ **High Risk - Needs Careful Testing**

### Characteristics
- Subprocess execution
- Uses mocking to avoid actual command execution
- Requires understanding of `shell=True` vs `shell=False`

### Why It's Challenging
- Must use mocking in tests (unittest.mock)
- LLM might try to use external tools (ffmpeg, imagemagick) not available
- Tests must verify subprocess parameters, not actual execution

### Implementation Pattern
```python
# Secure: shell=False with list
subprocess.run(['ls', filename], shell=False)

# Insecure: shell=True with string
subprocess.run(f'ls {filename}', shell=True)
```

### Potential Issues
- **CRITICAL:** Must only use built-in Unix commands (echo, ls, cat, pwd, date, whoami)
- Tests require proper mocking setup
- LLM might not understand mock assertions
- Complex test patterns may confuse generation

### Success Rate (Expected)
**50-70%** - May require multiple attempts or prompt refinement

---

## 5. XML External Entity (XXE)

**Status:** ⚠️ **Needs Testing - Dependency Risk**

### Characteristics
- XML parsing vulnerabilities
- May require `defusedxml` library
- Tests malicious XML with external entities

### Why It's Challenging
- Requires XML parsing library (xml.etree or defusedxml)
- External entity processing is subtle
- Tests need crafted malicious XML

### Implementation Pattern
```python
# Secure: Disable external entities
parser = ET.XMLParser()
parser.entity = {}  # Disable entities

# Insecure: Default parser
tree = ET.parse(xml_file)
```

### Potential Issues
- **CRITICAL:** May need to install defusedxml in Docker container
- LLM understanding of XXE exploitation may be limited
- Test patterns are complex
- Requires realistic XML examples

### Success Rate (Expected)
**40-60%** - High refinement needs, possible dependency issues

---

## 6. Insecure Deserialization (insecure_deser)

**Status:** ⚠️ **Needs Testing - Complex Pattern**

### Characteristics
- Pickle or YAML deserialization
- Secure version uses JSON
- Tests malicious payloads

### Why It's Challenging
- Requires understanding of serialization risks
- Malicious payload creation is complex
- Tests must verify code doesn't execute, not crash

### Implementation Pattern
```python
# Secure: Use JSON
data = json.loads(serialized_data)

# Insecure: Use pickle
data = pickle.loads(serialized_data)
```

### Potential Issues
- Creating malicious pickle/YAML payloads is advanced
- LLM might not generate proper exploit code
- Tests are conceptually difficult (verify non-execution)
- May require Python magic methods (`__reduce__`)

### Success Rate (Expected)
**30-50%** - High complexity, may need significant prompt work

---

## 7. Server-Side Request Forgery (SSRF)

**Status:** ⚠️ **Needs Testing - Network Mocking Required**

### Characteristics
- URL validation logic
- May involve HTTP requests
- Tests block internal IPs

### Why It's Challenging
- Might require requests library
- Tests should mock network calls
- IP validation logic can be subtle

### Implementation Pattern
```python
# Secure: Validate against whitelist, block internal IPs
if url.startswith('http://127.0.0.1'):
    raise ValueError("Internal IP blocked")

# Insecure: No validation
requests.get(user_provided_url)
```

### Potential Issues
- Network libraries (requests, urllib) need proper mocking
- IP validation logic is complex
- Tests must avoid actual network calls
- LLM might not understand SSRF exploitation patterns

### Success Rate (Expected)
**50-70%** - Moderate difficulty, depends on mocking quality

---

## 8. Weak Cryptography (weak_crypto)

**Status:** ⚠️ **Needs Testing - May Need Additional Libraries**

### Characteristics
- Password hashing and encryption
- Secure: bcrypt, scrypt, secrets module
- Insecure: MD5, SHA1, weak random

### Why It's Challenging
- May require bcrypt library (not built-in)
- Tests must verify algorithm strength
- Conceptual: how to test "weak" crypto?

### Implementation Pattern
```python
# Secure: bcrypt
import bcrypt
hashed = bcrypt.hashpw(password.encode(), bcrypt.gensalt())

# Insecure: MD5
import hashlib
hashed = hashlib.md5(password.encode()).hexdigest()
```

### Potential Issues
- **CRITICAL:** bcrypt might not be installed in container
- Tests need to verify algorithms used, not just functionality
- Predictability testing (weak random) is complex
- LLM might generate functional but insecure tests

### Success Rate (Expected)
**40-60%** - Dependency risk, conceptual testing challenges

---

## 9. Hardcoded Credentials (hardcoded_creds)

**Status:** ⚠️ **Needs Testing - Pattern Detection**

### Characteristics
- Credentials in source code
- Secure: environment variables
- Insecure: hardcoded strings

### Why It's Challenging
- Tests must inspect source code, not just functionality
- Static analysis pattern
- Both versions need to be functionally identical

### Implementation Pattern
```python
# Secure: Environment variables
password = os.getenv('DB_PASSWORD')

# Insecure: Hardcoded
password = "admin123"
```

### Potential Issues
- **CONCEPTUAL CHALLENGE:** Tests should fail on insecure version not because it doesn't work, but because credentials are hardcoded
- Requires source code inspection in tests
- LLM might not understand how to test for this
- Both versions work functionally - difference is in code structure

### Success Rate (Expected)
**30-50%** - Highly conceptual, unusual test pattern

---

## 10. Authentication Bypass (auth_bypass)

**Status:** ⚠️ **Needs Testing - Logic Flaw Pattern**

### Characteristics
- Login and authorization logic
- Secure: proper validation
- Insecure: flawed logic (always returns true, skips checks)

### Why It's Challenging
- Requires realistic authentication scenarios
- Flawed logic must be subtle but exploitable
- Tests must verify that invalid credentials fail

### Implementation Pattern
```python
# Secure: Proper validation
if username and password and check_password(username, password):
    return user

# Insecure: Logic flaw
if username or password:  # OR instead of AND
    return user
```

### Potential Issues
- LLM must create realistic but flawed authentication logic
- Tests must try various bypass techniques (empty strings, wrong passwords)
- Balance between "too obvious" and "actually works"
- Requires understanding of common authentication flaws

### Success Rate (Expected)
**60-75%** - Moderate complexity, depends on prompt quality

---

## Summary Matrix

| Vulnerability Type | Expected Success Rate | Main Challenge | Dependencies | Priority |
|-------------------|----------------------|----------------|--------------|----------|
| sqli | 95-100% | None | Built-in sqlite3 | ✅ High |
| xss | 85-95% | Code length, no frameworks | Built-in html | ✅ High |
| path_traversal | 70-85% | Avoid actual file ops | Built-in os.path | ⚠️ Medium |
| cmdi | 50-70% | Mocking, command restrictions | Built-in subprocess | ⚠️ Medium |
| xxe | 40-60% | Complex patterns, dependencies | xml.etree / defusedxml | ⚠️ Low |
| insecure_deser | 30-50% | Malicious payload creation | Built-in pickle/json | ⚠️ Low |
| ssrf | 50-70% | Network mocking | requests (may need install) | ⚠️ Medium |
| weak_crypto | 40-60% | Testing algorithm strength | bcrypt (may need install) | ⚠️ Medium |
| hardcoded_creds | 30-50% | Source code inspection | Built-in os | ⚠️ Low |
| auth_bypass | 60-75% | Realistic flawed logic | None | ⚠️ Medium |

---

## Recommendations for Week 2

### Priority 1: Confirm Working Types (Goal: 100% success rate)
1. **sqli** - Should already work perfectly
2. **xss** - Should work with current prompts

### Priority 2: High-Potential Types (Goal: >70% success rate)
3. **path_traversal** - Should work with prompt clarification
4. **auth_bypass** - Good conceptual clarity
5. **cmdi** - Requires careful mocking setup

### Priority 3: Moderate-Risk Types (Goal: >50% success rate)
6. **ssrf** - May need dependency check
7. **weak_crypto** - May need dependency check

### Priority 4: High-Risk Types (May need significant work)
8. **xxe** - Complex, low priority for thesis
9. **insecure_deser** - Very complex, may defer
10. **hardcoded_creds** - Unusual pattern, may defer

---

## Testing Strategy

1. **Phase 1:** Run `test_all_vulnerabilities.py` to get baseline success rates
2. **Phase 2:** Focus on Priority 1 & 2 types (aim for 5-7 working types)
3. **Phase 3:** Refine prompts for failed types
4. **Phase 4:** Document which types work reliably for user study

**Minimum Viable Goal:** 6-7 vulnerability types working reliably (60-70%)
**Stretch Goal:** 8-9 vulnerability types working (80-90%)
**Aspirational Goal:** All 10 types working (100%)

---

## For Supervisor Meeting

**Current Status:**
- ✅ All 10 types implemented in schema
- ✅ All 10 types have detailed prompt guidance
- ✅ All 10 types enabled for testing
- ⏳ Testing in progress to determine success rates

**Expected Outcome:**
- 2 types confirmed working (sqli, xss)
- 3-5 additional types likely working with minor refinement
- 2-3 types may require significant prompt engineering
- Realistic goal: 6-7 types working reliably for user study

**Risk Mitigation:**
- If some types prove unreliable, focus user study on working types
- Document success rates per type in thesis methodology
- Can still achieve research goals with 6-7 diverse vulnerability types
